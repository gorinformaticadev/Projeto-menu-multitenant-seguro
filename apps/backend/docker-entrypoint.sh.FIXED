#!/bin/sh
set -e

# Simple entrypoint: wait for DB, generate prisma client, run migrations, start app.

# Extrair hostname do DATABASE_URL
DB_HOST=$(echo "${DATABASE_URL}" | sed -n 's|.*@\([^:]*\):.*|\1|p')
if [ -z "$DB_HOST" ]; then
  DB_HOST="localhost"
fi

DB_PORT=${DB_PORT:-5432}

# Wait for DB readiness (pg_isready from postgresql-client package)
echo "Waiting for database at ${DB_HOST}:${DB_PORT} ..."
if command -v pg_isready >/dev/null 2>&1; then
  for i in $(seq 1 30); do
    if pg_isready -h "${DB_HOST}" -p "${DB_PORT}" >/dev/null 2>&1; then
      echo "Database is ready."
      break
    fi
    echo "Waiting for Postgres... (${i}/30)"
    sleep 2
  done
else
  echo "pg_isready not found; waiting 10s for DB to be up."
  sleep 10
fi

# Verificar se npx está disponível, senão usar o prisma do node_modules
if command -v npx >/dev/null 2>&1; then
  PRISMA_CMD="npx prisma"
else
  PRISMA_CMD="./node_modules/.bin/prisma"
fi

PRISMA_SCHEMA="/app/prisma/schema.prisma"

# Optionally generate Prisma client in runtime (disabled by default).
# Client is already generated during image build.
if [ "${RUN_PRISMA_GENERATE:-false}" = "true" ]; then
  echo "Generating Prisma client..."
  $PRISMA_CMD generate --schema "${PRISMA_SCHEMA}"
fi

# CORREÇÃO: Executar migrações por padrão em produção
# Para desabilitar, defina RUN_MIGRATIONS=false
if [ "${RUN_MIGRATIONS:-true}" = "true" ]; then
  echo "Running prisma migrate deploy..."
  $PRISMA_CMD migrate deploy --schema "${PRISMA_SCHEMA}" || {
    echo "⚠️  Prisma migrate failed. Attempting to push schema..."
    $PRISMA_CMD db push --schema "${PRISMA_SCHEMA}" --skip-generate || echo "❌ Database sync failed (continuing anyway)"
  }
else
  echo "Skipping migrations (RUN_MIGRATIONS=false)"
fi

# Start the app using package.json start:prod script (keeps runtime consistent)
exec npm run start:prod
