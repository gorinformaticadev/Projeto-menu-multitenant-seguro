#!/usr/bin/env bash

# ============================================================================
# update-acme - Atualizador para instalações ACME (Interno ou Externo)
# ============================================================================
# Este script atualiza o Projeto-menu-multitenant-seguro mantendo a
# compatibilidade com as configurações de Nginx (Docker ou Host).
#
# Uso:
#   sudo bash install/update-acme
# ============================================================================

set -Eeuo pipefail
IFS=$'\n\t'

# Cores para output
echoblue() { echo -ne "\033[44m\033[37m\033[1m  $1  \033[0m\n"; }
echored() { echo -ne "\033[41m\033[37m\033[1m  $1  \033[0m\n"; }
echogreen() { echo -ne "\033[42m\033[37m\033[1m  $1  \033[0m\n"; }
log_info() { echo -e "\033[1;34m[INFO]\033[0m $*"; }

require_root() {
    if [[ $EUID -ne 0 ]]; then
        echored "Este script deve ser executado como root"
        exit 1
    fi
}

# Localiza a instalação
find_install_dir() {
    log_info "Localizando diretório de instalação..."
    # Tenta o diretório padrão primeiro
    if [ -d "/opt/multitenant" ]; then
        INSTALL_DIR="/opt/multitenant"
    else
        # Busca por .env que contenha multitenant
        INSTALL_DIR=$(find / -maxdepth 4 -type f -name ".env" 2>/dev/null | xargs grep -l "DOMAIN=" 2>/dev/null | head -n 1 | xargs dirname 2>/dev/null || echo "")
    fi

    if [ -z "$INSTALL_DIR" ] || [ ! -d "$INSTALL_DIR" ]; then
        echored "Não foi possível localizar a instalação do Multitenant."
        exit 1
    fi
    log_info "Instalação encontrada em: $INSTALL_DIR"
}

update_app() {
    cd "$INSTALL_DIR"
    
    log_info "Verificando integridade do repositório Git..."
    if [ ! -d ".git" ]; then
        log_info "Diretório não é um repositório Git. Inicializando..."
        git init
        git remote add origin https://github.com/gorinformaticadev/Projeto-menu-multitenant-seguro.git
        git fetch origin
        git checkout -f main || git checkout -f master
    fi

    log_info "Buscando atualizações no Git..."
    git fetch --all
    
    # Salva alterações locais se houver
    if git rev-parse --git-dir > /dev/null 2>&1 && ! git diff-index --quiet HEAD --; then
        log_info "Salvando alterações locais temporariamente..."
        git stash push -m "Update ACME $(date +%Y%m%d_%H%M%S)"
    fi

    log_info "Atualizando código fonte..."
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    git pull origin "$current_branch" || git reset --hard "origin/$current_branch"

    # Carrega variáveis do .env para o shell atual para garantir que o docker compose as veja
    if [ -f ".env" ]; then
        log_info "Carregando variáveis do arquivo .env..."
        export $(grep -v '^#' .env | xargs)
    fi

    # Garante que variaveis essenciais existam no .env para evitar falhas no compose.
    ensure_env_var() {
        local key="$1"
        local value="$2"
        if ! grep -q "^${key}=" .env; then
            echo "${key}=${value}" >> .env
        fi
    }

    local domain
    domain="$(grep '^DOMAIN=' .env | head -n1 | cut -d'=' -f2-)"
    ensure_env_var "NEXT_PUBLIC_API_URL" "https://$domain/api"
    ensure_env_var "FRONTEND_URL" "https://$domain"
    ensure_env_var "PORT" "4000"
    ensure_env_var "NODE_ENV" "production"

    # Compatibilidade com diferentes compose do projeto.
    local db_user db_pass db_name
    db_user="$(grep '^DB_USER=' .env | head -n1 | cut -d'=' -f2-)"
    db_pass="$(grep '^DB_PASSWORD=' .env | head -n1 | cut -d'=' -f2-)"
    db_name="$(grep '^DB_NAME=' .env | head -n1 | cut -d'=' -f2-)"

    if [ -z "$db_user" ]; then
        db_user="$(grep '^POSTGRES_USER=' .env | head -n1 | cut -d'=' -f2-)"
    fi
    if [ -z "$db_pass" ]; then
        db_pass="$(grep '^POSTGRES_PASSWORD=' .env | head -n1 | cut -d'=' -f2-)"
    fi
    if [ -z "$db_name" ]; then
        db_name="$(grep '^POSTGRES_DB=' .env | head -n1 | cut -d'=' -f2-)"
    fi

    db_user="${db_user:-multitenant}"
    db_name="${db_name:-multitenant}"
    db_pass="${db_pass:-$(openssl rand -hex 16)}"

    ensure_env_var "DB_USER" "$db_user"
    ensure_env_var "DB_PASSWORD" "$db_pass"
    ensure_env_var "DB_NAME" "$db_name"
    ensure_env_var "POSTGRES_USER" "$db_user"
    ensure_env_var "POSTGRES_PASSWORD" "$db_pass"
    ensure_env_var "POSTGRES_DB" "$db_name"
    ensure_env_var "DATABASE_URL" "postgresql://$db_user:$db_pass@db:5432/$db_name"
    ensure_env_var "DOCKERHUB_USERNAME" "local"
    # Detecta o modo de instalação (Externo ou Interno)
    if grep -q "USE_EXTERNAL_NGINX=true" .env 2>/dev/null; then
        log_info "Detectado modo: Nginx Externo"
        # Removemos o 'pull' para evitar erro com imagens locais
        docker compose -f docker-compose.yml -f docker-compose.external-nginx.yml up -d --build --remove-orphans
    else
        log_info "Detectado modo: Nginx Interno (Docker Proxy)"
        
        # Garante que a rede do proxy existe
        local network_name=$(grep "PROXY_NETWORK=" .env | cut -d'=' -f2 || echo "nginx-proxy")
        if ! docker network inspect "$network_name" >/dev/null 2>&1; then
            log_info "Criando rede Docker ausente: $network_name"
            docker network create "$network_name"
        fi

        # Usa o novo arquivo de proxy se disponível
        if [ -f "docker-compose.proxy.yml" ]; then
            log_info "Aplicando configurações de rede e proxy..."
            # Removemos o 'pull' para evitar erro com imagens locais
            docker compose -f docker-compose.yml -f docker-compose.prod.external.yml -f docker-compose.proxy.yml up -d --build --remove-orphans
        else
            docker compose up -d --build --remove-orphans
        fi
    fi
}

main() {
    require_root
    find_install_dir
    update_app
    
    echogreen "=============================================="
    echogreen "  ATUALIZAÇÃO CONCLUÍDA COM SUCESSO!         "
    echogreen "=============================================="
}

main "$@"
